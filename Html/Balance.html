<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Balance Chart Canvas</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        .container {
            background: rgba(20,20,20,1);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 1000px;
            width: 100%;
        }
        h1 {
            color: #333;
            margin-bottom: 20px;
            font-size: 24px;
        }
        .chart-wrapper {
            position: relative;
            width: 100%;
            height: 400px;
        }
        canvas {
            cursor: crosshair;
        }
        .tooltip-balance {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(46, 46, 46, 0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 13px;
            pointer-events: none;
            display: none;
            z-index: 10;
            white-space: nowrap;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: transform 0.1s ease-out, opacity 0.1s ease-out;
        }
        .tooltip-balance.active {
            display: block;
        }
        .tooltip-stats {
            font-size: 14px;
            color: white;
            margin-bottom: 5px;
        }
        .tooltip-date-balance {
            font-size: 12px;
            color: #d1d5db;
        }
        .date-label {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(46, 46, 46, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 11px;
            pointer-events: none;
            display: none;
            z-index: 10;
            font-weight: 600;
        }

        .date-label.active {
            display: block;
        }

.circle-balance {
    display: none;
    position: absolute;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    z-index: 10;
    pointer-events: none;
    background: var(--circlebalance-color, rgb(13,185,129));
}

.circle-balance::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: var(--circlebalance-after-color, rgba(13,185,129, 0.6));
    transform: translate(-50%, -50%);
    animation: pulse-circlebalance 2s infinite;
}

@keyframes pulse-circlebalance {
    0% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
    100% { transform: translate(-50%, -50%) scale(3.5); opacity: 0; }
}

.time-filter {
    display: flex;
    gap: 8px;
    margin-bottom: 20px;
    justify-content: center;
}

.filter-btn {
    background: rgba(60, 60, 60, 0.6);
    color: #aaa;
    border: 1px solid rgba(80, 80, 80, 0.8);
    padding: 6px 12px;
    border-radius: 6px;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.filter-btn:hover {
    background: rgba(80, 80, 80, 0.8);
    color: #fff;
}

.filter-btn.active {
    background: rgba(13, 185, 129, 0.3);
    color: #0ffcc0;
    border-color: rgba(13, 185, 129, 0.6);
}
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ“Š Balance Chart USD</h1>
        <div class="time-filter">
            <button class="filter-btn active" data-range="all">ALL</button>
            <button class="filter-btn" data-range="24h">24H</button>
            <button class="filter-btn" data-range="7d">1W</button>
            <button class="filter-btn" data-range="1m">1M</button>
        </div>
        <div class="chart-wrapper">
            <canvas id="chartCanvasBalance"></canvas>
            <div class="tooltip-balance" id="tooltip-balance">
                <div class="tooltip-stats"></div>
                <div class="tooltip-date-balance"></div>
            </div>
            <div class="date-label" id="dateLabelBalance"></div>
            <div class="circle-balance" id="circlebalance"></div>
        </div>
    </div>

    <script>
        const canvasBalance = document.getElementById('chartCanvasBalance');
        const ctxBalance = canvasBalance.getContext('2d');
        const tooltipBalance = document.getElementById('tooltip-balance');
        const dateLabel = document.getElementById('dateLabelBalance');
                
        let balanceFullData = [];
        let balanceCurrentData = [];

        async function loadTradeHistory() {
            try {
                const response = await fetch('trade_history.json');
                if (!response.ok) throw new Error('Gagal memuat trade_history.json');
                const rawData = await response.json();

                rawData.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

                let cumulativeBalance = 0;
                const processedData = rawData.map(entry => {
                    cumulativeBalance += entry.pnl;
                    return {
                        date: new Date(entry.timestamp),
                        balance: parseFloat(cumulativeBalance.toFixed(2))
                    };
                });

                const firstDate = new Date(rawData[0].timestamp);
                firstDate.setHours(0, 0, 0, 0);
                balanceFullData= [{ date: firstDate, balance: 0 }, ...processedData];
                balanceCurrentData = [...balanceFullData];

                resizeBalanceCanvas();
            } catch (error) {
                console.error('Error loading trade history:', error);
                balanceFullData= [
                    { date: new Date('2025-01-01'), balance: 0 },
                    { date: new Date('2025-01-02'), balance: 5.3 }
                ];
                balanceCurrentData = [...balanceFullData];
                resizeBalanceCanvas();
            }
        }

        function filterData(range) {
            const now = new Date(); 
            const nowMs = now.getTime();
            let cutoffMs;

            switch (range) {
                case '24h': {
                    cutoffMs = nowMs - (24 * 60 * 60 * 1000);
                    break;
                }
                case '7d': {
                    const sevenDaysAgo = new Date(now);
                    sevenDaysAgo.setDate(now.getDate() - 6);
                    sevenDaysAgo.setHours(0, 0, 0, 0);
                    cutoffMs = sevenDaysAgo.getTime();
                    break;
                }
                case '1m': {
                    const thirtyDaysAgo = new Date(now);
                    thirtyDaysAgo.setDate(now.getDate() - 29);
                    thirtyDaysAgo.setHours(0, 0, 0, 0);
                    cutoffMs = thirtyDaysAgo.getTime();
                    break;
                }
                case 'all':
                default:
                    balanceCurrentData = [...balanceFullData];
                    drawBalanceChart();
                    return;
            }

            let filtered = balanceFullData.filter(d => d.date.getTime() >= cutoffMs && d.date.getTime() <= nowMs);

            if (filtered.length === 0 && balanceFullData.length > 0) {
                filtered = [balanceFullData[balanceFullData.length - 1]];
            }

            balanceCurrentData = filtered;
            drawBalanceChart();

            console.log(`Range "${range}" â†’ ${new Date(cutoffMs).toLocaleString()} s/d ${now.toLocaleString()}`);
        }

        function resizeBalanceCanvas() {
            const wrapper = canvasBalance.parentElement;
            canvasBalance.width = wrapper.clientWidth;
            canvasBalance.height = wrapper.clientHeight;
            drawBalanceChart();
        }

        // Format currency
        function formatBalanceCurrency(value) {
            return '$' + value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        }

        // Format date short
        function formatBalanceDateShort(date) {
            return date.toLocaleDateString('id-ID', { month: 'short', day: 'numeric' });
        }

        // Format date full
        function formatBalanceDateFull(date) {
            return date.toLocaleDateString('id-ID', { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            });
        }

        // Chart settings
        const padding = { top: 40, right: 40, bottom: 50, left: 80 };
        let balanceChartArea = {};
        let balancePoints = [];
        let balanceCurrentChartColor = 'rgb(13, 185, 129)';

        function drawBalanceChart() {
            ctxBalance.clearRect(0, 0, canvasBalance.width, canvasBalance.height);
            
            balanceChartArea = {
                left: padding.left,
                right: canvasBalance.width - padding.right,
                top: padding.top,
                bottom: canvasBalance.height - padding.bottom,
                width: canvasBalance.width - padding.left - padding.right,
                height: canvasBalance.height - padding.top - padding.bottom
            };

            // ==== FIND MIN/MAX BALANCE ====
            if (balanceCurrentData.length === 0) {
                return;
            }

            const balances = balanceCurrentData.map(d => d.balance);
            const minBalance = Math.min(...balances) * 0.9;
            const maxBalance = Math.max(...balances) * 1.1;

            // ==== GRID + Y VALUES ====
            ctxBalance.font = '12px Arial';
            ctxBalance.fillStyle = 'rgb(163, 163, 163)';
            ctxBalance.textAlign = 'right';
            const ySteps = 5;
            for (let i = 0; i <= ySteps; i++) {
                const value = minBalance + (maxBalance - minBalance) * (i / ySteps);
                const y = balanceChartArea.bottom - (balanceChartArea.height * i / ySteps);
                ctxBalance.fillText(formatBalanceCurrency(value), balanceChartArea.left - 10, y + 4);
            }

            // ==== HITUNG TITIK ====
            balancePoints = balanceCurrentData.map((d, i) => {
                const x = balanceChartArea.left + (balanceChartArea.width * i / (balanceCurrentData.length - 1 || 1));
                const normalizedValue = (d.balance - minBalance) / (maxBalance - minBalance);
                const y = balanceChartArea.bottom - (balanceChartArea.height * normalizedValue);
                return { x, y, date: d.date, balance: d.balance };
            });

            // ==== TENTUKAN WARNA BERDASARKAN PERGERAKAN ====
            let lineColor, gradientStart;
            balanceCurrentChartColor = lineColor;

            if (balanceCurrentData.length === 0) {
                lineColor = 'rgb(13, 185, 129)';
                gradientStart = 'rgba(13, 185, 129, 0.65)';
            } else if (balanceCurrentData.length === 1) {
                lineColor = 'rgb(13, 185, 129)';
                gradientStart = 'rgba(13, 185, 129, 0.65)';
            } else {
                const firstBalance = balanceCurrentData[0].balance;
                const lastBalance = balanceCurrentData[balanceCurrentData.length - 1].balance;

                if (lastBalance > firstBalance) {
                    lineColor = 'rgb(13, 185, 129)';
                    gradientStart = 'rgba(13, 185, 129, 0.65)';
                } else if (lastBalance < firstBalance) {
                    lineColor = 'rgb(239, 68, 68)';
                    gradientStart = 'rgba(239, 68, 68, 0.65)';
                } else {
                    lineColor = 'rgb(13, 185, 129)';
                    gradientStart = 'rgba(13, 185, 129, 0.65)';
                }
            }

            const circlebalance = document.getElementById('circlebalance');
            if (circlebalance) {
                circlebalance.style.background = lineColor;
                const match = lineColor.match(/\d+/g);
                if (match && match.length === 3) {
                    const [r, g, b] = match;
                    circlebalance.style.setProperty('--circlebalance-color', lineColor);
                    circlebalance.style.setProperty('--circlebalance-after-color', `rgba(${r}, ${g}, ${b}, 0.6)`);
                }
            }

            // ==== GRADIENT FILL ====
            const gradient = ctxBalance.createLinearGradient(0, balanceChartArea.top, 0, balanceChartArea.bottom);
            gradient.addColorStop(0, gradientStart);
            gradient.addColorStop(1, gradientStart.replace('0.65', '0').replace('0.65', '0'));
            const gradientEnd = gradientStart
                .replace(/[\d.]+(?=\))/, '0')
                .replace('0.65', '0');

            const baseColor = lineColor;
            const match = baseColor.match(/\d+/g);
            if (match && match.length === 3) {
                const [r, g, b] = match;
                gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.65)`);
                gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
            } else {
                gradient.addColorStop(0, 'rgba(13, 185, 129, 0.65)');
                gradient.addColorStop(1, 'rgba(13, 185, 129, 0)');
            }

            ctxBalance.fillStyle = gradient;
            ctxBalance.beginPath();
            ctxBalance.moveTo(balancePoints[0].x, balanceChartArea.bottom);
            ctxBalance.lineTo(balancePoints[0].x, balancePoints[0].y);

            for (let i = 0; i < balancePoints.length - 1; i++) {
                const p0 = balancePoints[i - 1] || balancePoints[i];
                const p1 = balancePoints[i];
                const p2 = balancePoints[i + 1];
                const p3 = balancePoints[i + 2] || p2;

                const cp1x = p1.x + (p2.x - p0.x) / 6;
                const cp1y = p1.y + (p2.y - p0.y) / 6;
                const cp2x = p2.x - (p3.x - p1.x) / 6;
                const cp2y = p2.y - (p3.y - p1.y) / 6;

                ctxBalance.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
            }

            ctxBalance.lineTo(balancePoints[balancePoints.length - 1].x, balanceChartArea.bottom);
            ctxBalance.closePath();
            ctxBalance.fill();

            // ==== GARIS UTAMA HALUS (CUBIC BEZIER) ====
            ctxBalance.strokeStyle = lineColor;
            ctxBalance.lineWidth = 3;
            ctxBalance.lineJoin = 'round';
            ctxBalance.lineCap = 'round';
            ctxBalance.shadowColor = 'rgba(20, 20, 20, 0.15)';
            ctxBalance.shadowBlur = 6;

            ctxBalance.beginPath();
            ctxBalance.moveTo(balancePoints[0].x, balancePoints[0].y);

            for (let i = 0; i < balancePoints.length - 1; i++) {
                const p0 = balancePoints[i - 1] || balancePoints[i];
                const p1 = balancePoints[i];
                const p2 = balancePoints[i + 1];
                const p3 = balancePoints[i + 2] || p2;

                const cp1x = p1.x + (p2.x - p0.x) / 6;
                const cp1y = p1.y + (p2.y - p0.y) / 6;
                const cp2x = p2.x - (p3.x - p1.x) / 6;
                const cp2y = p2.y - (p3.y - p1.y) / 6;

                ctxBalance.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
            }
            ctxBalance.stroke();
            ctxBalance.shadowBlur = 0;

            // ==== LABEL X-AXIS (TANGGAL) ====
            ctxBalance.fillStyle = 'rgb(163, 163, 163)';
            ctxBalance.font = '11px Arial';
            ctxBalance.textAlign = 'center';

            const maxLabels = 11;
            let step = 1;

            if (balancePoints.length > maxLabels) {
                step = Math.ceil(balancePoints.length / (maxLabels - 1));
            }

            // Pastikan titik pertama selalu muncul
            ctxBalance.fillText(formatBalanceDateShort(balancePoints[0].date), balancePoints[0].x, balanceChartArea.bottom + 20);

            // Tampilkan titik di tengah berdasarkan step
            for (let i = step; i < balancePoints.length - 1; i += step) {
                ctxBalance.fillText(formatBalanceDateShort(balancePoints[i].date), balancePoints[i].x, balanceChartArea.bottom + 20);
            }

            // Pastikan titik terakhir selalu muncul (jika belum ditampilkan)
            if (balancePoints.length > 1 && (balancePoints.length - 1) % step !== 0) {
                const last = balancePoints[balancePoints.length - 1];
                ctxBalance.fillText(formatBalanceDateShort(last.date), last.x, balanceChartArea.bottom + 20);
            }

            // === LAST PRICE circlebalance ===
            const last = balancePoints[balancePoints.length - 1];
            if (last) {
                circlebalance.style.display = 'block';
                circlebalance.style.left = `${last.x}px`;
                circlebalance.style.top = `${last.y}px`;
            } else {
                circlebalance.style.display = 'none';
            }
        }

        let balanceLastPoint = null;

        canvasBalance.addEventListener('mousemove', (e) => {
            const rect = canvasBalance.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const inChart = (
                mouseX >= balanceChartArea.left && mouseX <= balanceChartArea.right &&
                mouseY >= balanceChartArea.top && mouseY <= balanceChartArea.bottom
            );

            if (!inChart) {
                tooltipBalance.style.display = "none";
                dateLabel.style.display = "none";
                drawBalanceChart();
                balanceLastPoint = null;
                return;
            }

            let closestPoint = null;
            let minDist = Infinity;
            balancePoints.forEach(p => {
                const dist = Math.abs(p.x - mouseX);
                if (dist < minDist) {
                    minDist = dist;
                    closestPoint = p;
                }
            });

            if (!closestPoint) return;

            drawBalanceChart();

            // Vertical line
            ctxBalance.strokeStyle = balanceCurrentChartColor;
            ctxBalance.lineWidth = 1;
            ctxBalance.setLineDash([5, 5]);
            ctxBalance.beginPath();
            ctxBalance.moveTo(closestPoint.x, balanceChartArea.top);
            ctxBalance.lineTo(closestPoint.x, balanceChartArea.bottom);
            ctxBalance.stroke();
            ctxBalance.setLineDash([]);

            // Highlight point
            ctxBalance.fillStyle = '#fff';
            ctxBalance.beginPath();
            ctxBalance.arc(closestPoint.x, closestPoint.y, 2, 0, Math.PI * 2);
            ctxBalance.fill();

            tooltipBalance.style.display = "block";
            dateLabel.style.display = "block";

            if (!balanceLastPoint || balanceLastPoint !== closestPoint) {
                tooltipBalance.querySelector('.tooltip-stats').textContent = formatBalanceCurrency(closestPoint.balance);
                tooltipBalance.querySelector('.tooltip-date-balance').textContent = formatBalanceDateFull(closestPoint.date);
                const date = closestPoint.date;
                const monthDay = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                const time = date.toLocaleTimeString('en-GB', { hour12: false, hour: '2-digit', minute: '2-digit' });
                dateLabel.textContent = `${monthDay} ${time}`;
                balanceLastPoint = closestPoint;
            }

            let tooltipX = mouseX + 20;
            let tooltipY = mouseY - 80;

            const tooltipWidth = tooltipBalance.offsetWidth;
            const tooltipHeight = tooltipBalance.offsetHeight;

            if (tooltipX + tooltipWidth > balanceChartArea.right) {
                tooltipX = mouseX - tooltipWidth - 20;
            }
            if (tooltipY < balanceChartArea.top) {
                tooltipY = mouseY + 30;
            }

            tooltipBalance.style.left = tooltipX + 'px';
            tooltipBalance.style.top = tooltipY + 'px';

            const labelWidth = dateLabel.offsetWidth || 60;
            const labelTop = balanceChartArea.bottom + 10;

            const wrapperRect = canvasBalance.parentElement.getBoundingClientRect();
            const offsetLeft = rect.left - wrapperRect.left;

            let labelLeft = offsetLeft + closestPoint.x - (labelWidth / 2);

            if (labelLeft < 0) {
                labelLeft = offsetLeft + closestPoint.x - labelWidth * 0.25;
            } else if (labelLeft + labelWidth > wrapperRect.width) {
                labelLeft = offsetLeft + closestPoint.x - labelWidth * 0.75;
            }

            labelLeft = Math.max(4, Math.min(wrapperRect.width - labelWidth - 4, labelLeft));

            dateLabel.style.left = `${labelLeft}px`;
            dateLabel.style.top = `${labelTop}px`;

        });

        canvasBalance.addEventListener('mouseleave', () => {
            tooltipBalance.style.display = "none";
            dateLabel.style.display = "none";
            balanceLastPoint = null;
            drawBalanceChart();
        });



        // Initial draw
        resizeBalanceCanvas();
        loadTradeHistory();
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                filterData(btn.dataset.range);
            });
        });
        window.addEventListener('resize', resizeBalanceCanvas);
    </script>
</body>
</html>